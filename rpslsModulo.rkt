#lang simply-scheme

;Anthony Andrews Rock-Paper-Scissors-Lizzard-Spock using modulo
; run this code ten times to get each possible outcome (on average) or comment out the last line to play against the computer

(define (randThrow) ; create a function to return a psuedo random integer from 1 through 5
    (let ((x (random 5) ))
        (cond 
            ( (equal? x 0) 1 )
            ( (equal? x 1) 2 )
            ( (equal? x 2) 3 )
            ( (equal? x 3) 4 )
            ( (equal? x 4) 5 )
        )
    )
)

(define (throwName y) ; translates the values generated by the randThrow computer into their respective throw names.
    (cond
        ( (equal? y 1) 'rock)
        ( (equal? y 2) 'spock)
        ( (equal? y 3) 'paper)
        ( (equal? y 4) 'lizzard)
        ( (equal? y 5) 'scissors)
    )
)

(define (rpsls humThrow)
    (let ((compThrow (randThrow))) ; assigns the variable x to the integer created by the randThrow function.
        (let ((x (remainder (+ (- humThrow compThrow ) 5 ) 5 ) )) ; do the maths and assign the variable x to the remainder.
            (cond ; check if the remainder (x) corresponds to a tie, loss, or win.
                ( (equal? x 0) ; tie
                    (sentence (throwName humThrow) 'tied (throwName compThrow )) ; call the throwName function passing in the; throws given to get their respective throw names, then concatenate them into a sentance.
                )
                ( (equal? x 1) ; win
                    (sentence (throwName humThrow) 'beat (throwName compThrow ))
                )
                ( (equal? x 2) ; win
                    (sentence (throwName humThrow) 'beat (throwName compThrow ))
                )
                ( (equal? x 3) ;loss
                    (sentence (throwName humThrow) '(lost to) (throwName compThrow ))
                )
                ( (equal? x 4) ; loss
                    (sentence (throwName humThrow) '(lost to) (throwName compThrow ))
                )
            )
        )
    )
)
